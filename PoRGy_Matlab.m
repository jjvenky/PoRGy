function [p, bounds, q] = PoRGy_Matlab(filename)
% Single-file MATLAB implementation of the PoRGy model of O2 saturation
% and d18O-O2.
% This is complete but needs more comments and optimising.
% The idea was to include all necessary functions into one M-file so that
% it was (1) easier to pass around and (2) would export all the relevant
% data with one command.
%
% [p, bounds] = PoRGy_Matlab(filename)
% p is the struct of fitted variables
% bounds is the struct of bounds placed on p
% and filename is the base filename of the field data (n.b. 'ticks around filename')
%
% An example of how to call this function:
%        [p, bounds] = PoRGy_Matlab('s_sask_hague');
%
% The r2 values and SSE value will scroll by as MATLAB find a best-fit.
% Three output files are created with filenames like these:
% s_sask_hague_PoRGy-matlab_output_20070514T111545.csv
% s_sask_hague_PoRGy-matlab_output_20070514T111545.png
% s_sask_hague_PoRGy-matlab_output_summary_20070514T111545.csv
%
% Copyright 2007-2008 Jason J. Venkiteswaran & Kevin K. Venkiteswaran
%
% Revision 1.04 2008-12-11
%   added code to report cell q with all output data/results required when
%   running PoRGy_Matlab in a loop; re-organised and documented the sse
%   calculation
% Revision 1.03 2008-01-01
%   added new code for making publication-quality figures
% Revision 1.02 2007-12-29
%   re-organized the reduce_model_fit and PRLM so they are run once, at the
%   beginning and their values then passed throughout the model
% Revision 1.01 2007-06-06
%   change for non-*nix figures
%   fix help info
% Revision 1.00 2007-05-30
% 
% Do not distrubute this work.


%% time and date stamp
% Get the time here so that the figure and output data will have the same time-date stamp
modelruntime = datestr(now, 30);


%% import diel_input file
% diel_input has the location and bounds data
eval([filename '_diel_input']);


%% set up bounds and Starting variable based on diel_input
% First, find a random number for each variable within the bounds
p.P = bounds.P(1) + rand .* (bounds.P(2) - bounds.P(1));
p.R = bounds.R(1) + rand .* (bounds.R(2) - bounds.R(1));
p.k = bounds.k(1) + rand .* (bounds.k(2) - bounds.k(1));
p.alphaR = bounds.alphaR(1) + rand .* (bounds.alphaR(2) - bounds.alphaR(1));
p.d18OH2O = bounds.d18OH2O(1) + rand .* (bounds.d18OH2O(2) - bounds.d18OH2O(1));

% Second, transform the p and then assign to Starting because fminsearch
% takes a matrix (Starting) and not a struct (p and p_trans)
[p_trans] = transform(p, bounds);
Starting = [p_trans.P p_trans.R p_trans.k p_trans.alphaR p_trans.d18OH2O];


%% import the field_data
% this csv file has the format:
% 38183.2916666667,73.6,20.96
% first column is the date in excel numeric format
% second column is O2 saturation in % but without the % character
% third column is the δ18O-O2 in ‰ but without the ‰ character
field = load([filename '_field_data.csv']);
t = field(:,1);
Data = field(:,2);
Dataiso = field(:,3);
f = [t Data Dataiso];


%% precalculations for optimization purposes
% determine the row indices we can reduce mdata by to match fdata's precision
mdata_timestep = generate_mdata_timesteps(filename);
mdata_row_indices = calculate_reduce_model_data(f, mdata_timestep, 1, 1);

% run the PRLM
SolarConstant = 1367; % Solar Constant of 1367 W/m2, this does fluctuate and some authors have suggested slightly different values, but the actual value doesn't matter for our use
PRLMoutput = PRLM(altitude, aspect, dt, siml, slope, transmisivity, DayOfYear, DST, Latitude, Longitude, SolarConstant, TZ, Year);


%% call fminsearch
% Define function and starting point of fitting routine.
fun = @expfun;

% Set up the options for fminsearch
options = optimset('fminsearch');   % Use FMINSEARCH defaults
[Estimates, FVAL, EXITFLAG, OPTIONS] = fminsearch(fun, Starting, options, t, Data, Dataiso, filename, bounds, mdata_row_indices, PRLMoutput)


%% check the fit generated by fminsearch and make figures
% To check the fit visually, rerun the model with the "last" set of Estimates
% and grab the O2sat and d18OO2 data from the model.
% This is essentially:
% [tmodel, O2satmodel, d18OO2model] = O2model(Estimates(1), Estimates(2), Estimates(3), Estimates(4), Estimates(5), filename, bounds, PRLMoutput);

% Switch "last" set of Estimates back to the struct p_trans before passing
% to detransform.
p_trans.P = Estimates(1);
p_trans.R = Estimates(2);
p_trans.k = Estimates(3);
p_trans.alphaR = Estimates(4);
p_trans.d18OH2O = Estimates(5);
[p] = detransform(p_trans, bounds);
[tmodel, O2satmodel, d18OO2model, O2concmodel, ExcelDate, Rmass, Pmass, GEmass, GErate] = O2model(p.P, p.R, p.k, p.alphaR, p.d18OH2O, filename, bounds, PRLMoutput);

% Create one nice looking figure!
figure1 = figure('Color',[1 1 1]);
set(figure1, 'Position',[1,1,400,700], 'PaperPositionMode','auto', 'PaperUnits','points', 'PaperSize',[400,700]);

% first plot
ax1 = subplot(4,1,1,'Parent',figure1);
hold on
h1 = plot(t, Data, 'ro', 'MarkerFaceColor', 'r');
h2 = plot(tmodel, O2satmodel, 'b-', 'LineWidth', 2);
xl1 = xlim;
h8 = plot(xl1, [100 100], 'k:', 'LineWidth', 2);
%xlabel('Time');
datetick('x','HH:MM','keeplimits');
set(ax1,'xticklabel',[]); % to remove the labels from the top subplot
ylabel('O_{2} saturation (%)');
% use the title of the top subplot to title the entire figure
%title(filename, 'FontSize',16, 'Interpreter','none');
hold off

% second plot
ax2 = subplot(4,1,2,'Parent',figure1);
hold on
h3 = plot(t, Dataiso, 'ro', 'MarkerFaceColor', 'r');
h4 = plot(tmodel, d18OO2model, 'b-', 'LineWidth', 2);
xl2 = xlim;
h9 = plot(xl2, [24.2 24.2], 'k:', 'LineWidth', 2);
xlabel('Time');
datetick('x','HH:MM','keeplimits');
% the ‰ character is screwy in matlab, use per mill instead
ylabel('\delta^{18}O-O_{2} (per mill)'); 
hold off

% third plot
ax3 = subplot(4,1,[3 4],'Parent',figure1);
hold on
h5 = plot(Data, Dataiso, 'ro', 'MarkerFaceColor', 'r');
h6 = plot(O2satmodel, d18OO2model, 'b-', 'LineWidth', 2);
h7 = plot(100, 24.2, 'ko');
xl3 = xlim;
yl3 = ylim;
text(100, 24.2, 'ASW ' ,'HorizontalAlignment', 'right');
xlabel('O_{2} saturation (%)')
% the ‰ character is screwy in matlab, use per mill instead
ylabel('\delta^{18}O-O_{2} (per mill)');
%legend('data', 'PoRGy fit');
hold off

% fix the y-axes on ax1 and ax2 so they are the same as the cross-plot
set(ax1,'ylim',xl3);
set(ax2,'ylim',yl3);

% Write a PNG file with the 3-panel figure from the model run
% File has date and time appended to name
saveas(figure1, [filename '_PoRGy-matlab_output_' modelruntime '.png'], 'png');


%% export the model data and results 
% Write a CSV file with summary results from the model run.
% File has date and time appended to name.
% Thigs to export: p, bounds, r2, summary rates.

% export p
header = fieldnames(p)';
footer = struct2cell(p)';
out = [header ; footer];
fid=fopen([filename '_PoRGy-matlab_output_summary_' modelruntime '.csv'],'w'); % w for write since it's the first data
[rows,cols]=size(out);
fprintf(fid,'%s,',out{1,1:cols});
fprintf(fid,'\n');
fprintf(fid,'%f,',out{2,1:end});
fprintf(fid,'\n\n');
fclose(fid);

% export bounds
%header = fieldnames(bounds)'; % won't work since bounds have two values per fieldname
header = {'Pboundmin' 'Pboundmax' 'Rboundmin' 'Rboundmax' 'kboundmin' 'kboundmax' 'alphaRboundmin' 'alphaRboundmax' 'd18OH2Oboundmin' 'd18OH2Oboundmax'};
footer = struct2cell(bounds)';
%out = [header ; q]; % won't work
fid=fopen([filename '_PoRGy-matlab_output_summary_' modelruntime '.csv'],'a'); % a for append
[rows,cols]=size(header);
fprintf(fid,'%s,',header{1,1:cols});
fprintf(fid,'\n');
[rows,cols]=size(footer);
fprintf(fid,'%f,',footer{1,1:cols});
fprintf(fid,'\n\n');
fclose(fid);

% export rates and ratios
% we know that:
    % days_modelled = siml/24;
    % modelrows = siml / dt / days_modelled;
    modelrows = 24 / dt;

P = sum(Pmass((1:modelrows),:)) / modelrows / Area;
R = sum(Rmass((1:modelrows),:)) / modelrows / Area;
G = sum(abs(GEmass((1:modelrows),:))) / modelrows / Area;
PRG_rates_0h_to_0h = [P R G];
P_to_R_0h_to_0h = P ./ R;
P_to_G_0h_to_0h = P ./ G;
R_to_G_0h_to_0h = R ./ G;

q = [{modelruntime} P R G P_to_R_0h_to_0h P_to_G_0h_to_0h R_to_G_0h_to_0h];

header = {'P rate' 'R rate' 'G* rate' 'P:R' 'P:G' 'R:G'};
footer = [P R G P_to_R_0h_to_0h P_to_G_0h_to_0h R_to_G_0h_to_0h];
fid=fopen([filename '_PoRGy-matlab_output_summary_' modelruntime '.csv'],'a'); % a for append
header1 = {'mid-night to mid-night rates and ratios'};
[rows,cols]=size(header1);
fprintf(fid,'%s',header1{1,1:cols});
fprintf(fid,'\n');
[rows,cols]=size(header);
fprintf(fid,'%s,',header{1,1:cols});
fprintf(fid,'\n');
fprintf(fid,'%f,',footer);
fprintf(fid,'\n\n');
fclose(fid);

P = sum(Pmass(( 12 / dt : (modelrows + 12 / dt) ),:)) / modelrows / Area;
R = sum(Rmass(( 12 / dt : (modelrows + 12 / dt) ),:)) / modelrows / Area;
G = sum(abs(GEmass(( 12 / dt : (modelrows + 12 / dt) ),:))) / modelrows / Area;
PRG_rates_12h_to_12h = [P R G];
P_to_R_12h_to_12h = P ./ R;
P_to_G_12h_to_12h = P ./ G;
R_to_G_12h_to_12h = R ./ G;

header = {'P rate' 'R rate' 'G* rate' 'P:R' 'P:G' 'R:G'};
footer = [P R G P_to_R_12h_to_12h P_to_G_12h_to_12h R_to_G_12h_to_12h];
fid=fopen([filename '_PoRGy-matlab_output_summary_' modelruntime '.csv'],'a'); % a for append
header1 = {'noon to noon rates and ratios'};
[rows,cols]=size(header1);
fprintf(fid,'%s',header1{1,1:cols});
fprintf(fid,'\n');
[rows,cols]=size(header);
fprintf(fid,'%s,',header{1,1:cols});
fprintf(fid,'\n');
fprintf(fid,'%f,',footer);
fprintf(fid,'\n\n');
fclose(fid);

% export r2 values
% If we want the r2 values, then we have to run through the
% reduce_model_data routine again.

% Organise the output for the reduce_model_data function.
m = [tmodel, O2satmodel, d18OO2model];

% We get the field data and parse it.
field = load([filename '_field_data.csv']);
t = field(:,1);
Data = field(:,2);
Dataiso = field(:,3);
f = [t Data Dataiso];
f_reduced = reduce_model_data(f, m, mdata_row_indices, 1:size(m,2));

% We get back the f matrix but with three "extra" columns
% of matching data from m, date, sat, and d18OO2.
m_reduced = [f_reduced(:,4) f_reduced(:,5), f_reduced(:,6)];

% The r2 is only for output b/c it's an easy number to look at and understand.
% We need to find a better measure of fit b/c the data is related through
% time and thus not independant.
r2saturation = corr(m_reduced(:,2), f(:,2)) .^2;
r2iso = corr(m_reduced(:,3), f(:,3)) .^2;
header = {'r2 saturation' 'r2 d18OO2'};
footer = [r2saturation r2iso];
fid=fopen([filename '_PoRGy-matlab_output_summary_' modelruntime '.csv'],'a'); % a for append
[rows,cols]=size(header);
fprintf(fid,'%s,',header{1,1:cols});
fprintf(fid,'\n');
fprintf(fid,'%f,',footer);
fprintf(fid,'\n\n');
fclose(fid);

q = [q P R G P_to_R_12h_to_12h P_to_G_12h_to_12h R_to_G_12h_to_12h r2saturation r2iso];

% Write a CSV file with relevant data from the model run.
% File has date and time appended to name.
header = {'ExcelDate' 'O2conc' 'O2satpercent' 'd18OO2' 'Pmass' 'Rmass' 'GEmass'};
fid=fopen([filename '_PoRGy-matlab_output_data_' modelruntime '.csv'],'w'); % w for write since it's the first data
[rows,cols]=size(header);
fprintf(fid,'%s,',header{1,1:cols});
fprintf(fid,'\n');
fclose(fid);
footer = [ExcelDate O2concmodel O2satmodel d18OO2model Pmass Rmass GEmass];
dlmwrite([filename '_PoRGy-matlab_output_data_' modelruntime '.csv'],footer,'-append','precision','%.4f');



%%  the fun expfun
% ---------- all calculations inside the fminsearch "loop" (expfun) are below ----------
function sse = expfun(params, t, Data, Dataiso, filename, bounds, mdata_row_indices, PRLMoutput)
% Accepts curve parameters as inputs, and outputs the error for the
% O2model versus field data pairs.

% fminsearch will always use transformed variables so we can always
% detransform them here BEFORE passing them to the O2model.
% fminsearch starts with params and we pass that to detransform
% Switch params back to the struct p_trans before passing to detransform
p_trans.P = params(1);
p_trans.R = params(2);
p_trans.k = params(3);
p_trans.alphaR = params(4);
p_trans.d18OH2O = params(5);
[p] = detransform(p_trans, bounds);
P = p.P;
R = p.R;
k = p.k;
alphaR = p.alphaR;
d18OH2O = p.d18OH2O;


% Go through the model and generate model data based on some input params.
[tmodel, O2sat, d18OO2] = O2model(P, R, k, alphaR, d18OH2O, filename, bounds, PRLMoutput);

% Organise the output for the reduce_model_data function.
m = [tmodel, O2sat, d18OO2];

% Take the model data and get the see.
% Have to reduce the model data to get comparable pairs of data b/c
% field_data is not sampled at the same/common frequency.
% First, we get the field data and parse it.
field = load([filename '_field_data.csv']);
t = field(:,1);
Data = field(:,2);
Dataiso = field(:,3);
f = [t Data Dataiso];
f_reduced = reduce_model_data(f, m, mdata_row_indices, 1:size(m,2));

% We get back the f matrix but with three "extra" columns
% of matching data from m, date, sat, and d18OO2.
m_reduced = [f_reduced(:,4) f_reduced(:,5), f_reduced(:,6)];


%% Select the type of SSE calculations
% When curve fitting, a typical quantity to minimize is the sum of squares
% error. However since both saturation and d18OO2 need to be fit a single
% value must be derived.  Both saturation and d18OO2 are in different units
% and have different ranges, i.e. saturation values tend to be higher than
% d18OO2.  Thus the data need to be  standardised into z-score to adjust
% for this.  Z-score = (x-mu)/sigma = (x-mean(x))/std(x).

zsat = (f(:,2) - mean(m_reduced(:,2))) ./ std(m_reduced(:,2)); % field data
ziso = (f(:,3) - mean(m_reduced(:,3))) ./ std(m_reduced(:,3)); % field data
zSAT = (m_reduced(:,2) - mean(m_reduced(:,2))) ./ std(m_reduced(:,2)); % model output
zISO = (m_reduced(:,3) - mean(m_reduced(:,3))) ./ std(m_reduced(:,3)); % model output

% Sum of squared error for each of saturation and d18OO2 needs to be
% calculated. This is sum(y - yhat).^2.

sse = sum( (zSAT - zsat).^2 + (zISO - ziso).^2 );

% The r2 is only for output b/c it's an easy number to look at and understand
% We need to find a better measure of fit b/c the data is related through
% time and thus not independant.
r2saturation = corr(m_reduced(:,2), f(:,2)) .^2;
r2iso = corr(m_reduced(:,3), f(:,3)) .^2;

% The visual_output is for comparing different types of fits:
disp([r2saturation r2iso sse./size(f,1)]); % display the r2 and n-corrected SSE values


% ---------- all calculations inside the fminsearch "loop" (expfun) are above ----------


%% transform function
function [p_trans] = transform(p, bounds)
% Inverse sine to transform the values.

% Use a sine transformation e.g. p.P = asin(p_trans.P) + b has minimum value of (b-a)
% and maximum value of (b+a), so if the prescribed bounds are bmax and bmin
% then a and b are a=(bmax-bmin)/2 and b=(bmax+bmin)/2 .
a = (bounds.P(2) - bounds.P(1))/2;
b = (bounds.P(2) + bounds.P(1))/2;
p_trans.P  = asin((p.P-b)/a);
a = (bounds.R(2) - bounds.R(1))/2;
b = (bounds.R(2) + bounds.R(1))/2;
p_trans.R  = asin((p.R-b)/a);
a = (bounds.k(2) - bounds.k(1))/2;
b = (bounds.k(2) + bounds.k(1))/2;
p_trans.k  = asin((p.k-b)/a);
a = (bounds.alphaR(2) - bounds.alphaR(1))/2;
b = (bounds.alphaR(2) + bounds.alphaR(1))/2;
p_trans.alphaR  = asin((p.alphaR-b)/a);
a = (bounds.d18OH2O(2) - bounds.d18OH2O(1))/2;
b = (bounds.d18OH2O(2) + bounds.d18OH2O(1))/2;
p_trans.d18OH2O  = asin((p.d18OH2O-b)/a);


%% detransform function
function [p] = detransform(p_trans, bounds)
% Sine to detransform the values.

% Use a sine transformation e.g. p.P = asin(p_trans.P) + b has minimum value of (b-a)
% and maximum value of (b+a), so if the prescribed bounds are bmax and bmin
% then a and b are a=(bmax-bmin)/2 and b=(bmax+bmin)/2 .
a = (bounds.P(2) - bounds.P(1))/2;
b = (bounds.P(2) + bounds.P(1))/2;
p.P = a * sin(p_trans.P) + b;
a = (bounds.R(2) - bounds.R(1))/2;
b = (bounds.R(2) + bounds.R(1))/2;
p.R = a * sin(p_trans.R) + b;
a = (bounds.k(2) - bounds.k(1))/2;
b = (bounds.k(2) + bounds.k(1))/2;
p.k = a * sin(p_trans.k) + b;
a = (bounds.alphaR(2) - bounds.alphaR(1))/2;
b = (bounds.alphaR(2) + bounds.alphaR(1))/2;
p.alphaR = a * sin(p_trans.alphaR) + b;
a = (bounds.d18OH2O(2) - bounds.d18OH2O(1))/2;
b = (bounds.d18OH2O(2) + bounds.d18OH2O(1))/2;
p.d18OH2O = a * sin(p_trans.d18OH2O) + b;


%% generate model timestep
function [mdata_timestep] = generate_mdata_timesteps(filename)
% generate_mdata_timesteps(filename)
%
% Generate an model data matrix that includes only the timesteps.

  % eval to get the variables we use
  eval([filename '_diel_input']);

  DaysElapsed = round((1:siml/dt)' * dt / 24 - 0.5);
  LocalHour = mod((1:siml/dt)' * dt, 24);
  SolarHour = LocalHour - (-4 * Longitude / 60 - ( - TZ) + DST);  % 4 min/deg plus time zone adjustments

  % SET UP DATE CONVERSION FOR COMPARISON TO FIELD DATA
  % Excel uses the whole and fractional number of days from 1-Jan-1900
  % Matlab uses "the whole and fractional number of days from 1-Jan-0000 to a
  % specific date. The year 0000 is merely a reference point and is not 
  % intended to be interpreted as a real year in time."
  % Therefore, the switch from Julian to Gregorian calenders doesn't matter here
  % the +2 is required to count the "first" and "last" days in the brackets
  mdata_timestep = (datenum([Year 01 DayOfYear]) - datenum([1900 1 1]) + 2) + DaysElapsed + LocalHour / 24;



%% O2model
function [t, O2satpercent, d18OO2, O2conc, ExcelDate, Rmass, Pmass, GEmass, GErate] = O2model(Pmaxrate, Rrate20, k, alphaR, d18OH2O, filename, bounds, PRLMoutput)
% O2 model used for fitting data.
% function [t, O2satpercent, d18OO2] = O2model(Pmaxrate, Rrate20, k, alphaR, d18OH2O, filename, bounds, PRLMoutput)
%
% 2006-05-17 JJV

% GET FIELD LOCATION DETAILS
eval([filename '_diel_input']);
Volume = Area * Depth; % in m3


% SET UP LENGTH OF MODEL RUN
% DEFINE THE TIME AXIS
% Matrices like "real positive integers" so tp is used as an integer-based
% counter from 0 up and is based on the total number of time steps as per
% siml/dt (where siml is total hours of simulation and dt is time step
% in fractional hours).
tp = (0:siml/dt-1)';


% SETUP CLOCK SYSTEM FOR PRLM AND USEFUL COMPARISON WITH tp
DaysElapsed = round((1:siml/dt)' * dt / 24 - 0.5);
LocalHour = mod((1:siml/dt)' * dt, 24);
SolarHour = LocalHour - (-4 * Longitude / 60 - ( - TZ) + DST);  % 4 min/deg plus time zone adjustments


% SET UP DATE CONVERSION FOR COMPARISON TO FIELD DATA
% Excel uses the whole and fractional number of days from 1-Jan-1900
% Matlab uses "the whole and fractional number of days from 1-Jan-0000 to a
% specific date. The year 0000 is merely a reference point and is not 
% intended to be interpreted as a real year in time."
% Therefore, the switch from Julian to Gregorian calenders doesn't matter here
% the +2 is required to count the "first" and "last" days in the brackets
ExcelDate = (datenum([Year 01 DayOfYear]) - datenum([1900 1 1]) + 2) + DaysElapsed + LocalHour / 24;
t = ExcelDate;


% SET UP TEMPERATURE	
% Temperature: (set via input) [1 == sine surve with max and min | 2 == 5th order polynomial]
if Tswitch == 1
    Tdelay = 2.5;
    Tmodifier = (1 + sin(pi * ((SolarHour + Tdelay) + 12) / 12)) / 2;
    TinC = Tmin_in_C * (1 - Tmodifier) + Tmax_in_C * (Tmodifier);
elseif Tswitch == 2
    TinC = Tpoly5 * LocalHour .^ 5 + Tpoly4 * LocalHour .^ 4 + Tpoly3 * LocalHour .^ 3 + Tpoly2 * LocalHour .^ 2 + Tpoly1 * LocalHour .^ 1 + Tpoly0;
else TinC = 20;
end
TinK = TinC + 273.15; % set up temperatures in kelvins


% FORCE SOME BASIC SETTINGS
% Conversion factors and constants
% alphaR respiration fractionation factor (set via input)
% d18OH2O delta of the water (set via input)
alphaGeq = (-0.72951 + 426.96 ./ TinK) / 1000 + 1; % equilibrium enrichment factor Benson & Krause 1984, fits very well up to 100C with Benson et al. 1979 table VIII, which has good data to 60C
alphaGk = 0.9972; % ratio of k values of both isotopomers, Knox et al. 1992
alphaP = 1.000; % photosynthetic fractionation factor, Guy et al. 1993, 1995, Helman et al. 2005, Stevens et al. 1975
Lperm3 = 1000; % conversion from L to m3
m3perL = 0.001; % conversion from m3 to L
RatioVSMOW = 0.0020052; % the 18:16 ratio of VSMOW
Ratioair = 0.0020523; % the 18:16 ratio of O2 in air based on VSMOW and air=+23.5‰
RatioH2O = RatioVSMOW * (d18OH2O / 1000 + 1); % the 18:16 ratio of O in H2O


% SET UP P
% Set the photosynthetic production of O2 by rate
% Pswitch (set via input) [0|1] [0 == sine wave | 1 == PRLM model]
if Pswitch == 0
    Prate = Pmaxrate * (sin(2 * pi * dt * (tp - 6) / 24)) * Area; % the tp/24 is to set the sine wave cycle to 1/24; tp-6 to shift the curve so curve maxes out at noon
    for i = 1:siml/dt
    if Prate(i, 1) < 0
       Prate(i, 1) = 0;
    end
    end
else
%KKV    PRLMoutput = PRLM(altitude, aspect, dt, siml, slope, transmisivity, DayOfYear, DST, Latitude, Longitude, SolarConstant, TZ, Year);
    Prate = Pmaxrate * PRLMoutput;
end
Pmass = Prate * Area; % This does not have to be in a loop b/c it is only multiplication
Pmassiso = Pmass * (RatioH2O * alphaP);


% SET UP R
% Set the respiratory consuption of O2 via rate
% Rrate = IF RArrheniusswitch=1 THEN Rrate20*(1.047^(TinC-20)) ELSE Rrate20
% RArrheniusswitch (set via input) [0|1] [0 == no Arrhenius correction | 1 == Arrhenius correction]
if RArrheniusswitch == 1
	Rrate = Rrate20 * (1.047 .^ (TinC - 20)); % 1.047 is from Borsuk et al. 2004
   Rmass = Rrate * Area;
    %    Rmassiso(i, 1) = Rmass(i, 1) * (RatioO2(i, 1) * alphaR) % This has to
    %    be in the big loop b/c it relies on the RatioO2 that gets calculated
    %    each cycle through the loop
else
    Rrate = Rrate20;
    Rmass = Rrate * Area;
end


% SET UP k
% Set gas exchange rate of O2 via k and concentration. Currently this just
% copies the same k value to each cell in the matrix, but can easily be
% changed to handle changing k.
k = ones(siml/dt,1) * k;


% SET UP MATRICES
% Preallocate the variables that are in the loop
preallocsize = (siml/dt); % size of matrices to preallocate
O2mass = zeros(preallocsize,1);
d18OO2 = zeros(preallocsize,1);
RatioO2 = zeros(preallocsize,1);
O2massiso = zeros(preallocsize,1);
O2conc = zeros(preallocsize,1);
GErate = zeros(preallocsize,1);
GEmass = zeros(preallocsize,1);
GEmassiso = zeros(preallocsize,1);
O2mass(1, 1) = O2concinit * Lperm3 * Volume;
RatioO2(1, 1) = RatioVSMOW * (d18OO2init / 1000 + 1);
O2massiso(1, 1) = O2mass(1, 1) * RatioO2(1, 1);
O2conc(1, 1) = O2mass(1, 1) / Volume * m3perL;


% O2 saturation concentration based on Weiss 1970 DSR data is 0-40C
% atmospheric pressure correction added in the same manner as in PRLM
% O2satconc has to be calculated out before the GE loop
% O2satconc = EXP(-173.4292+249.6339*(100/TinK)+143.3483*LOGN(TinK/100)-21.8492*(TinK/100) + 0*(-0.033096+0.014259*(TinK/100)-0.0017000*(TinK/100)^2) )*1.4276
O2satconc_1atm = exp(-173.4292 + 249.6339 * (100 ./ TinK) + 143.3483 * log(TinK ./ 100) - 21.8492 * (TinK ./ 100) + salinity * (-0.033096 + 0.014259 * (TinK ./ 100) - 0.0017000 * (TinK ./ 100) .^ 2)) * 1.4276;
AtmPressure_Correction = ((288.15 - 0.0065 * altitude) / 288.15) ^ 5.256; % close enough b/c "P=Po e (-Mgz/RT)" is within 0.001 between 10-20C
O2satconc = O2satconc_1atm * AtmPressure_Correction;
O2satpercent(1, 1) = O2conc(1, 1) / O2satconc(1, 1) * 100;


% CALCULATE MATRICES ONE TIME STEP AT A TIME
% Iterate over all values to calculate O2mass
% 1. For GE, use the O2conc and O2satconc from the previous timeset to
% calculate the GEmass required for the current time step
% 2. Then calculate the O2conc for each timestep that is just finishing so
% that the O2conc is ready for the next timestep
for i = 2:siml/dt
    GErate(i, 1) = k(i, 1) * (O2satconc(i-1, 1) - O2conc(i-1, 1)) * Lperm3;
    GEmass(i, 1) = GErate(i, 1) * Area;
    GEmassiso(i, 1) = k(i, 1) * alphaGk * ( (O2satconc(i-1, 1) * Ratioair * alphaGeq(i, 1)) - (O2conc(i-1, 1) * RatioO2(i-1, 1)) ) * Area * Lperm3;
    O2mass(i, 1) = O2mass(i-1, 1) + (GEmass(i, 1) + Pmass(i, 1) - Rmass(i, 1)) * dt;
%    O2mass(i, 1) = O2mass(i-1, 1) + (GEmass(i, 1) + Pmass(i, 1) - Rmass(i, 1)) * dt + (21600 * 8.3 - 21600 * O2conc(i-1, 1)) * dt;
    Rmassiso(i, 1) = Rmass(i, 1) * (RatioO2(i-1, 1) * alphaR);
    O2massiso(i, 1) = O2massiso(i-1, 1) + (Pmassiso(i, 1) + GEmassiso(i, 1) - Rmassiso(i, 1)) * dt;
%    O2massiso(i, 1) = O2massiso(i-1, 1) + (Pmassiso(i, 1) + GEmassiso(i, 1) - Rmassiso(i, 1)) * dt + (21600 * 8.3 * Ratioair * 1.0007 - 21600 * O2conc(i-1, 1) * RatioO2(i-1, 1)) * dt;
    O2conc(i, 1) = O2mass(i, 1) / Volume * m3perL;
    RatioO2(i, 1) = O2massiso(i, 1) / O2mass(i, 1);
end
O2satpercent = O2conc ./ O2satconc .* 100;
d18OO2 = ((RatioO2 ./ RatioVSMOW) - 1) .* 1000;


%% PRLM
function [PRLMoutput, PotentialRadiation] = PRLM(altitude, aspect, dt, siml, slope, transmisivity, DayOfYear, DST, Latitude, Longitude, SolarConstant, TZ, Year)
% Potential Radiation Light Model
% Takes 11 inputs and returns the PRLM in fraction relative to max, fraction relative to the SolarConstant, and W/m2
% (which can be used as the PRLMPmaxmodifier)
% [PRLMoutput, PotentialRadiation] = PRLM(altitude, aspect, dt, siml, slope, transmisivity, DayOfYear, DST, Latitude, Longitude, SolarConstant, TZ, Year)

% Two variables that do not (currently) change
SolarDeclination = -23.45 * cos(360 * (DayOfYear + 10) / 365 * pi / 180);
AtmPressure_Correction = ((288.15 - 0.0065 * altitude) / 288.15) ^ 5.256; % close enough b/c "P=Po e (-Mgz/RT)" is within 0.001 between 10-20C
Souterlayer = SolarConstant * (1 + 0.034 * cos((2 * pi * DayOfYear / 365)));
    
% Setup clock system for PRLM and useful comparison with tp
DaysElapsed = round((1:siml/dt)' * dt / 24 - 0.5);
LocalHour = mod((1:siml/dt)' * dt, 24);
SolarHour = LocalHour - (-4 * Longitude / 60 - ( - TZ) + DST);  % 4 min/deg plus time zone adjustments

% Most variables have to be calculated in the loop b/c they rely on time in
% some way or another
% Preallocate the variables that are in the loop
preallocsize = (siml/dt);
SolarAltitude2 = zeros(preallocsize,1);
SolarAltitude1 = zeros(preallocsize,1);
cosIncide = zeros(preallocsize,1);
OpCorr = zeros(preallocsize,1);
%Snormal = zeros(preallocsize,1); % causes problems
Sdirect = zeros(preallocsize,1);
%Souterlayer = zeros(preallocsize,1); % causes problems
Sdiffusive = zeros(preallocsize,1);

for i = 1:siml/dt
    HourAng(i, 1) = 15 * (SolarHour(i, 1) - 12.01);
    % This two equation setup is a result of Stella not being able to do arcsin
    SolarAltitude2(i, 1) = sin(Latitude * pi / 180) * sin(SolarDeclination * pi / 180) + cos(Latitude * pi / 180) * cos(SolarDeclination * pi / 180) * cos(HourAng(i, 1) * pi / 180);
    SolarAltitude1(i, 1) = atan(SolarAltitude2(i, 1) / (sqrt(1 - SolarAltitude2(i, 1) ^ 2))) *180 / pi;
    SolarAzimuth(i, 1) = min(0.999, ((sin(SolarDeclination * pi / 180) * cos(Latitude * pi / 180) * sin(Latitude * pi / 180) * cos(HourAng(i, 1) * pi / 180)) / cos(SolarAltitude1(i, 1) * pi / 180)));
    %SolarAzimuthCorrection = IF(SolarHour < 12) THEN SolarAzimuth ELSE (360 - SolarAzimuth)
    if SolarHour(i, 1) < 12
        SolarAzimuthCorrection(i, 1) = SolarAzimuth(i, 1);
    else
        360 - SolarAzimuth(i, 1);
    end
    cosIncide(i, 1) = sin(SolarAltitude1(i, 1) * pi / 180) * cos(slope * pi / 180) + cos(SolarAltitude1(i, 1) * pi/180) * sin(slope * pi / 180) * cos((SolarAzimuth(i, 1) - aspect) * pi / 180);
    OpCorr(i, 1) = transmisivity ^ ((sqrt(1229 + (614 * sin(SolarAltitude1(i, 1) * pi / 180)) ^ 2) - 614 * sin(SolarAltitude1(i, 1) * pi / 180)) * AtmPressure_Correction);
    % Souterlayer will go here once DayOfYear becomes variable
    Snormal(i, 1) = OpCorr(i, 1) * Souterlayer;
    % Sdirect = IF Snormal*cosIncide < 0 THEN 0 ELSE Snormal*cosIncide
    if Snormal(i, 1) * cosIncide(i, 1) < 0
        Sdirect(i, 1) = 0;
    else
        Sdirect(i, 1) = Snormal(i, 1) * cosIncide(i, 1);
    end
    % Sdiffusive = IF (Souterlayer * (0.271 - 0.294 * OpCorr) * SIN(SolarAltitude1 * pi / 180)) < 0 THEN 0 ELSE (Souterlayer * (0.271 - 0.294 * OpCorr) * SIN(SolarAltitude1 * pi / 180))
    if (Souterlayer * (0.271 - 0.294 * OpCorr(i, 1)) * sin (SolarAltitude1(i, 1) * pi / 180)) < 0
        Sdiffusive(i, 1) = 0;
    else
        Sdiffusive(i, 1) = (Souterlayer * (0.271 - 0.294 * OpCorr(i, 1)) * sin (SolarAltitude1(i, 1) * pi / 180));
    end
end

Stotal = Sdirect + Sdiffusive;
PotentialRadiation = Stotal;
PRLMoutput = PotentialRadiation / SolarConstant;


%% precalculate row indices for model reduction
function [row_indices] = calculate_reduce_model_data(fdata, mdata, fdata_compare, mdata_compare)
% calculate_reduce_model_data(fdata, mdata, fdata_compare, mdata_compare)
%
% Precalculate the indices of the rows to remove from the model data
% to match the "precision" in the field data. This optimizes the many
% calls to reduce_model_data done inside of the fminsearch call.

  % return value: a vector the size of the # of rows in fdata, filled with the
  % row numbers to extract from mdata
  row_indices = zeros(size(fdata,1), 1);

  % loop over the mdata for values (in mdata_compare) that
  % are larger than but as close to the values in fdata's fdata_compare.
  % upon a match we record the row index.

  f = 1;                         % row counter in fdata
  m = 1;                         % row counter in mdata
  while (m < size(mdata,1))

    % check if we have a match for fdata
    if mdata(m, mdata_compare) >= fdata(f, fdata_compare)

      % mdata(m_current_row) is >= fdata(f_current_row). but is this
      % closer than m_current_row - 1? (m_current_row + 1 can't be closer)

      delta_m_prev = abs(mdata(m-1, mdata_compare) - fdata(f, fdata_compare));
      delta_m = abs(mdata(m, mdata_compare) - fdata(f, fdata_compare));
      src_row = m;

      if delta_m_prev <= delta_m
        src_row = m - 1;
      end

      row_indices(f) = src_row;

      m = m - 1;  % decrement m so we hit row m on the next for loop       
      f = f + 1;

      % if we have matching rows for all the field data then quit
      if f > size(fdata,1)
        break
      end

    end                 % if: matched row in f
    m = m + 1;
  end                   % while: loop over m


%% reduce model fit
function [fdata] = reduce_model_data(fdata, mdata, row_indices, mdata_append_cols)
% reduce_model_data(fdata, mdata, row_indices, mdata_append_cols)
%
% "Reduce" model data to the frequency of the field data. The rows we reduce
% to are precalculated in calculate_reduce_model_data.
%
% mdata represents model data sampled at a higher frequency than field
% data stored in fdata. row_indices is a vector specifying the row numbers
% in mdata, and mdata_append_cols specifies the columnds, to copy into 
% fdata. The resulting fdata is returned.

  % record the number of columns in fdata. we append data to the right of 
  % the existing columns
  fdata_cols = size(fdata, 2);

  % fdata( all rows, colsize of data:new colsize of fdata) = mdata(rows specified in rows_indices, cols to copy)
  fdata(:, (fdata_cols+1):(fdata_cols+size(mdata_append_cols,2)) ) = mdata(row_indices, mdata_append_cols);


%% EOF
